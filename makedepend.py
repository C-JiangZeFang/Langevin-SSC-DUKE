#!/usr/bin/env python3

import re
import os
import sys
import argparse, textwrap


def main():
    # Parse command line arguments.
    parser = argparse.ArgumentParser(
            formatter_class = argparse.RawDescriptionHelpFormatter,
            description = textwrap.dedent("""
                Creates a dependency file (Makefile snippet) for:
                  - linking executables for C/C++ (lists .o files)
                  - headers and modules for Fortran

                C/C++:
                  GCC output header dependencies when compiling C/C++ code but no linking
                  dependency is solved.  This script assumes that every included header with
                  an associated implementation file should be linked in the final executable.

                Fortran:
                  In case of Fortran code, gfortran will not generate header dependencies
                  automatically, this script tries to fill role.  However, linking is much
                  more involved since Fortran language doesn't enforce subroutines and
                  functions to be previously declared.  Therefore, it would be necessary to
                  parse the whole program looking for all possible calls and then blindly for
                  their definition in other files.  This script will not do that.  Linking
                  dependencies for Fortran code should be done MANUALLY in the Makefile.


                The script assumes a certain work flow in order to work properly:
                  - Executable sources (files containing the main() function for C/C++ or the
                    'program' instruction for Fortran) must be named 'main_name.ext' where
                    'name' is the final executable name and ext corresponds to .c, .cpp or
                    .f90 appropriately.
                  - Header files (.h|.hpp|.inc) are never compiled as they are meant to be
                    included in other source files.
                  - Implementation files associated with a header must have the same basename
                    of the header file. Ex: aheader.hpp may have an implementation file named
                    aheader.cpp.  Note: mixing-language programs may have two headers
                    associated with the same implementation file.
                  - C/C++ code is assumed to be compiled with -MMD -MP -MF flags, this script
                    will not generate header dependencies which are already generated by
                    these flags.
                  - The script assumes the Makefile contains certain variables, namely:
                    SRCDIR INCDIR BINDIR, for the location of the sources, headers and final
                    binaries, respectively.
                  - Fortran files can define at most one module and the file base name must
                    be all lowercase. Ex: module FooMod must be the only module defined in
                    foomod.f90 file.
                  - Fortran code is assumed to be free-form.
                """))
    parser.add_argument(
        '-I',
        action='store',
        type=str,
        default='include',
        help='Where to look for header files. [include/]',
        metavar='incdir')
    parser.add_argument(
        '-s',
        action='store',
        type=str,
        default='src',
        help='Where to look for source files. [src/]',
        metavar='srcdir')
    parser.add_argument(
        '-o',
        nargs='?',
        type=argparse.FileType('w'),
        default=sys.stdout,
        help='Output file.  Print to stdout if not given.',
        metavar='output')
    parser.add_argument(
        'filelist',
        type=str,
        nargs='+',
        help='Source file(s) to build dependencies for.',
        metavar='file')
    args = parser.parse_args()

    # Setup paths
    output = args.o
    curdir = os.path.join(os.path.dirname(sys.argv[0]), '')
    incdir = os.path.join(curdir, args.I, '')
    srcdir = os.path.join(curdir, args.s, '')
    programs = { os.path.basename(name) for name in args.filelist }

    # Setup filenames
    srcext = [ '.c', '.cpp', '.f90', '.f' ]
    incext = [ '.h', '.hpp', '.inc' ]

    global is_fortran
    def is_fortran(filename):
        return filename.endswith(('.f', '.f90', '.inc'))

    global basename
    def basename(filename):
        return os.path.splitext(filename)[0]

    global get_program
    def get_program(basename):
        return basename.replace('main_','$(BINDIR)/')

    global get_object
    def get_object(srcname):
        return os.path.splitext(srcname)[0] + '.o'

    global get_module
    def get_module(basename):
        basename = basename.lower()
        for ext in ['.f90', '.f']:
            if os.path.isfile(srcdir + basename + ext):
                return '$(SRCDIR)/' + basename + '.mod'

    global get_source
    def get_source(basename):
        for ext in srcext:
            filename = basename + ext
            if os.path.isfile(srcdir + filename):
                return '$(SRCDIR)/' + filename
        return None

    global get_include
    def get_include(basename):
        for ext in incext:
            filename = basename + ext
            if os.path.isfile(incdir + filename):
                return '$(INCDIR)/' + filename
        return None

    global get_realfile
    def get_realfile(filename):
        filename = filename.replace('$(SRCDIR)', srcdir)
        filename = filename.replace('$(INCDIR)', incdir)
        return filename

    # Fill list of dependencies
    depend_table = {}
    fortran_headers = {}
    for item in programs:
        depend_list = set()
        if is_fortran(item):
            fill_header_deplist(depend_list, item)
            fortran_headers[get_source(basename(item))] = depend_list
        else:
            item = basename(item)
            fill_object_deplist(depend_list, item)
            depend_table[get_program(item)] = depend_list

    # Write output
    write_depend_table(output, depend_table, fortran_headers)


def fill_header_deplist(depend_list, filename):
    if filename.endswith('.inc'):
        filename = '$(INCDIR)/' + filename
    else:
        filename = '$(SRCDIR)/' + filename

    if filename not in depend_list:
        depend_list.add(filename)
        filename = get_realfile(filename)
        if not os.path.isfile(filename):
            return

        # parse content of file
        contents = ''
        with open(filename) as fd:
            for line in fd:
                contents += line

        # recursively scan file for headers
        includepattern = re.compile(r'''^ *include *["'](.*)['"]''', re.M | re.IGNORECASE)
        for included in re.findall(includepattern, contents):
            fill_header_deplist(depend_list, included)

        if not filename.endswith('.inc'):
            # if it is a source file we look for module
            # we only want direct module dependency, so no recursion is done
            modulepattern = re.compile(r'''^ *use +([^ \n]*)$''', re.M | re.IGNORECASE)
            for module in re.findall(modulepattern, contents):
                module = get_module(module)
                if module:
                    depend_list.add(module)



def fill_object_deplist(depend_list, basename):
    files = list(filter(None.__ne__, [ get_include(basename), get_source(basename) ]))

    for file in files:
        if file not in depend_list:
            depend_list.add(file)
            file = get_realfile(file)

            # parse content of file
            contents = ''
            with open(file) as fd:
                for line in fd:
                    contents += line

            # recursively scan file
            includepattern = re.compile(r'^#include *[<"](.*)[">]', re.M)
            for included in re.findall(includepattern, contents):
                fill_object_deplist(depend_list, os.path.splitext(included)[0])



def write_depend_table(output, depend_table, fortran_headers):
    self_depend= set()

    for program, deplist in depend_table.items():
        output.write(program + ':')
        for item in deplist:
            self_depend.add(item)
            if item.startswith('$(SRCDIR)'):
                output.write(' ' + get_object(item))
        output.write('\n\n')

    for source, deplist in fortran_headers.items():
        output.write(get_object(source) + ':')
        self_depend.add(source)
        for item in deplist:
            if source != item:
                output.write(' ' + item)
        output.write('\n\n')

    depend_filename = output.name
    output.write(depend_filename + ': ' + ' '.join(self_depend) + '\n\n')
    for item in self_depend:
        output.write(item + ':\n\n')


if __name__ == "__main__":
    main()
else:
    raise ImportError("This module is not supposed to be imported...")
